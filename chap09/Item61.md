# [Item 61] 박싱된 기본 타입보다는 기본 타입을 사용하라.

자바의 데이터 타입은 기본형과 참조형이 있습니다. 기본형에 대응하는 참조 타입이 하나씩 있으며 이를 박싱된 기본 타입이라 합니다. 기본 타입과 박싱된 기본 타입은 분명한 차이가 있으며 용도에 맞게 사용해야합니다.</br>
박싱된 기본 타입은 값 뿐만 아니라 식별성이 더해졌습니다. 즉 값이 같아도 서로 다르게 식별될 수 있습니다. 그리고 박싱 타입은 **null**을 가질 수 있습니다. 추가로 기본 타입은 박싱 타입보다 메모리와 시간 측면에서 더 효율적입니다.</br>

``` java
// 잘못 구현된 비교자
Comparator<Integer> naturalOrder = 
    (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```
컴파일 오류도 생기지 않고 잘 실행되지만 런타임에서 엉뚱한 결과가 발생할 수 있습니다. new Integer(10), new Integer(10) 똑같은 값이지만 0이 아닌 1을 출력합니다. 첫번째 (i < j)는 오토언박싱이 일어나서 정상적으로 작동합니다. 하지만 (i == j)에서는 참조를 비교하기 때문에 false가 나오게 됩니다. 실무에서는 이와 같이 기본 타입을 다루는 비교자가 필요하면 `Comparator.naturalOrder`를 사용합시다. 비교자를 직접 만들면 비교자 생성 메서드나 기본타입을 받는 정적 compare 메서드를 사용해야 합니다.</br>
이 문제를 해결하려면 지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본타입으로 저장한 다음, 비교를 수행해야 합니다.

``` java
// 문제를 수정한 비교자
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed;
    reutrn i < j ? -1 : (i == j ? 0 : 1);
};
```
다음은 시간에 대한 문제입니다.

``` java
Long sum = 0L;
for(long i = 0; i <= Integer.MAX_VALUE; i++) {
    sum += i;
}
System.out.println(sum);
```
박싱과 언박싱이 반복되면서 굉장히 성능이 저하되는 걸 확인할 수 있습니다.



